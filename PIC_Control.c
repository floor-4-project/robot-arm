#pragma config(ProgramType, NonCompetition)
#pragma config(Sensor, in1,    CLAW_ON,        sensorDigitalOut)
#pragma config(Sensor, in2,    CLAW_TILT_ON,   sensorDigitalOut)
#pragma config(Sensor, in3,    LOWER_ARM_ON,   sensorDigitalOut)
#pragma config(Sensor, in4,    UPPER_ARM_ON,   sensorDigitalOut)
#pragma config(Sensor, in5,    TURNTABLE_ON,   sensorDigitalOut)
#pragma config(Sensor, in6,    CLAW_FORWARD,   sensorDigitalOut)
#pragma config(Sensor, in7,    CLAW_TILT_FORWARD, sensorDigitalOut)
#pragma config(Sensor, in8,    LOWER_ARM_FORWARD, sensorDigitalOut)
#pragma config(Sensor, in9,    UPPER_ARM_FORWARD, sensorDigitalOut)
#pragma config(Sensor, in10,   TURNTABLE_FORWARD, sensorDigitalOut)
#pragma config(Sensor, in12,   VALID_RUNTIME,  sensorDigitalOut)
#pragma config(Sensor, in13,   STATE_0,        sensorDigitalOut)
#pragma config(Sensor, in14,   STATE_1,        sensorDigitalOut)
#pragma config(Sensor, in16,   LED,            sensorDigitalOut)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* DOCUMENTATION */
/* signalSend - Sends the signals to the motors on the rising edge of the signal
* axis0, axis1, axis2 - Binary signal to determine axis
* axis0 is least significant, axis2 is most significant [000 = axis0-axis1-axis2]
*
* 000 - Undefined
* 001 - Claw Motor
* 010 - Claw Tilting Motor
* 011 - Undefined
* 100 - Upper Arm Motor
* 101 - Lower Arm Motor
* 110 - Turntable Motor
* 111 - Undefined
*
* motorOutput[] -> [0] = axis0, [1] = axis1, [2] = axis2
*
* motorA, motorB, motorC, motorD - Phases of the stepper motors
*
*
*
*/

/* Program Variables */
int joystickThreshold = 30;

struct { // Holds values based on which motors are enabled
	bool claw;
	bool clawTilting;
	bool upperArm;
	bool lowerArm;
	bool turntable;
}Motors;
Motors motors;

struct { // Holds direction values for each motor
	bool clawForward;
	bool clawTiltingForward;
	bool upperArmForward;
	bool lowerArmForward;
	bool turntableForward;
}MotorDirections;
MotorDirections motorDirections;

struct { // Holds phase values for stepper motors
	bool motorAState;
	bool motorBState;
	bool motorCState;
	bool motorDState;
}MotorState;
MotorState motorState;

void initialize() { // Initialize all variable values
	motors.claw = false;
	motors.clawTilting = false;
	motors.upperArm = false;
	motors.lowerArm = false;
	motors.turntable = false;

	motorDirections.clawForward = true;
	motorDirections.clawTiltingForward = true;
	motorDirections.upperArmForward = true;
	motorDirections.lowerArmForward = true;
	motorDirections.turntableForward = true;

	motorState.motorAState = false;
	motorState.motorBState = false;
	motorState.motorCState = false;
	motorState.motorDState = false;
}

bool isJoystickActive() { // Check to see if any manual input is being received, return as boolean
	if (abs(vexRT[Ch1]) > joystickThreshold || abs(vexRT[Ch2]) > joystickThreshold) {
		return true;
	} else if (abs(vexRT[Ch3]) > joystickThreshold || abs(vexRT[Ch4]) > joystickThreshold) {
		return true;
	} else if (abs(vexRT[Ch5]) > joystickThreshold) {
		return true;
	}
	return false;
}

void sendMotors() { // Send the motor enabled state off of the PIC and to the Arduino
	if (motors.claw) {
		SensorValue[CLAW_ON] = 1;
	} else {
		SensorValue[CLAW_ON] = 0;
	}

	if (motors.clawTilting) {
		SensorValue[CLAW_TILT_ON] = 1;
	} else {
		SensorValue[CLAW_TILT_ON] = 0;
	}

	if (motors.lowerArm) {
		SensorValue[LOWER_ARM_ON] = 1;
	} else {
		SensorValue[LOWER_ARM_ON] = 0;
	}

	if (motors.upperArm) {
		SensorValue[UPPER_ARM_ON] = 1;
	} else {
		SensorValue[UPPER_ARM_ON] = 0;
	}

	if (motors.turntable) {
		SensorValue[TURNTABLE_ON] = 1;
	} else {
		SensorValue[TURNTABLE_ON] = 0;
	}
}

void sendMotorDirections() { // Send the direction of each motor off the PIC and to the Arduino
	if (motorDirections.clawForward) {
		SensorValue[CLAW_FORWARD] = 1;
	} else {
		SensorValue[CLAW_FORWARD] = 0;
	}

	if (motorDirections.clawTiltingForward) {
		SensorValue[CLAW_TILT_FORWARD] = 1;
	} else {
		SensorValue[CLAW_TILT_FORWARD] = 0;
	}

	if (motorDirections.lowerArmForward) {
		SensorValue[LOWER_ARM_FORWARD] = 1;
	} else {
		SensorValue[LOWER_ARM_FORWARD] = 0;
	}

	if (motorDirections.upperArmForward) {
		SensorValue[UPPER_ARM_FORWARD] = 1;
	} else {
		SensorValue[UPPER_ARM_FORWARD] = 0;
	}

	if (motorDirections.turntableForward) {
		SensorValue[TURNTABLE_FORWARD] = 1;
	} else {
		SensorValue[TURNTABLE_FORWARD] = 0;
	}
}

void manualClawTilt() {
	if (abs(vexRT[Ch1]) > joystickThreshold) {
		motors.clawTilting = true;
		if (vexRT[Ch1] > 0) { // Move the arm up
			motorDirections.clawTiltingForward = true;
			} else { // Move the arm down
			motorDirections.clawTiltingForward = false;
			}
		} else {
		motors.clawTilting = false;
	}
}

void manualUpperArm() {
	if (abs(vexRT[Ch2]) > joystickThreshold) {
		motors.upperArm = true;
		if (vexRT[Ch2] > 0) { // Move the arm up
			motorDirections.upperArmForward = true;
			} else { // Move the arm down
			motorDirections.upperArmForward = false;
			}
		} else {
		motors.upperArm = false;
	}
}

void manualLowerArm() {
	if (abs(vexRT[Ch3]) > joystickThreshold) {
		motors.lowerArm = true;
		if (vexRT[Ch3] > 0) { // Move the arm up
			motorDirections.lowerArmForward = true;
			} else { // Move the arm down
			motorDirections.lowerArmForward = false;
			}
		} else {
		motors.lowerArm = false;
	}
}

void manualTurntable() {
	if (abs(vexRT[Ch4]) > joystickThreshold) {
		motors.turntable = true;
		if (vexRT[Ch4] > 0) { // Move the arm up
			motorDirections.turntableForward = true;
			} else { // Move the arm down
			motorDirections.turntableForward = false;
			}
		} else {
		motors.turntable = false;
	}
}

void manualClaw() {
	if (abs(vexRT[Ch5]) > joystickThreshold) {
		motors.claw = true;
		if (vexRT[Ch5] > 0) { // Move the arm up
			motorDirections.clawForward = true;
			} else { // Move the arm down
			motorDirections.clawForward = false;
			}
		} else {
		motors.claw = false;
	}
}

void sendValidRuntime() {
	SensorValue[VALID_RUNTIME] = 1;
	wait1Msec(100);
	SensorValue[VALID_RUNTIME] = 0;
	wait1Msec(100);
}

void disableAllOutputs() {
	SensorValue[CLAW_ON] = 0;
	SensorValue[CLAW_TILT_ON] = 0;
	SensorValue[LOWER_ARM_ON] = 0;
	SensorValue[UPPER_ARM_ON] = 0;
	SensorValue[TURNTABLE_ON] = 0;

	SensorValue[CLAW_FORWARD] = 0;
	SensorValue[CLAW_TILT_FORWARD] = 0;
	SensorValue[LOWER_ARM_FORWARD] = 0;
	SensorValue[UPPER_ARM_FORWARD] = 0;
	SensorValue[TURNTABLE_FORWARD] = 0;

	SensorValue[STATE_0] = 0;
	SensorValue[STATE_1] = 0;
}

void sendState(int state0, int state1) {
	SensorValue[STATE_0] = state0;
	SensorValue[STATE_1] = state1;
}

void ledGoodConnection() {
	SensorValue[LED] = 0;
	wait1Msec(1000);
	SensorValue[LED] = 1;
	wait1Msec(100);
	SensorValue[LED] = 0;
}

void ledDisconnect() {
	SensorValue[LED] = 0;
	wait1Msec(500);
	SensorValue[LED] = 1;
	wait1Msec(100);
	SensorValue[LED] = 0;
	wait1Msec(100);
	SensorValue[LED] = 1;
	wait1Msec(100);
	SensorValue[LED] = 0;
}

task statusControl() { // Create LED patterns in seperate task for debugging
	while(true) {
		if (nVexRCReceiveState != 0) {
			ledGoodConnection();
		} else {
			ledDisconnect();
		}
	}
}

task armStateMachine() { // Depending on the inputs, send out a different control state
	int controllerState = 0;
	while(true) {
		if (isJoystickActive()) { // If any manual control is active, switch to state 1
			controllerState = 0;
			} else if (vexRT[Ch6] > 0) { // If Button 1 is pressed, activate state 1
			controllerState = 1;
			} else if (vexRT[Ch6] < 0) { // If Button 2 is pressed, activate state 2
			controllerState = 2;
		}

		switch(controllerState) { // Send states off of PIC to Arduino
		case 0:
			sendState(0, 0);
			break;
		case 1:
			sendState(0, 1);
			break;
		case 2:
			sendState(1, 0);
			break;
		}
	}
}

/*
* Need to send:
* Digital Out for each motor, if the motor is enabled
* Digital Out for each motor direction
*
*/
task main() {
	initialize();
	bVexAutonomousMode = false;
	StartTask(armStateMachine);
	StartTask(statusControl);
	while(true) {
		sendValidRuntime(); // Used as a kill-switch in the case where the VEX PIC crashes. Acts as a "deads-man" switch
		if (nVexRCReceiveState != 0) { // Only send values when the receiver is connected
			// Watch for controller inputs on each system
			manualClawTilt();
			manualUpperArm();
			manualLowerArm();
			manualTurntable();
			manualClaw();

			// Send motor states out
			sendMotors(); // Send values for motors
			sendMotorDirections(); // Send directions for motors
		} else {
			disableAllOutputs(); // Set 0 to all outputs
		}
	}
}
