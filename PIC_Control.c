#pragma config(ProgramType, NonCompetition)
#pragma config(Sensor, in1,    CLAW_ON,        sensorDigitalOut)
#pragma config(Sensor, in2,    CLAW_TILT_ON,   sensorDigitalOut)
#pragma config(Sensor, in3,    LOWER_ARM_ON,   sensorDigitalOut)
#pragma config(Sensor, in4,    UPPER_ARM_ON,   sensorDigitalOut)
#pragma config(Sensor, in5,    TURNTABLE_ON,   sensorDigitalOut)
#pragma config(Sensor, in6,    CLAW_FORWARD,   sensorDigitalOut)
#pragma config(Sensor, in7,    CLAW_TILT_FORWARD, sensorDigitalOut)
#pragma config(Sensor, in8,    LOWER_ARM_FORWARD, sensorDigitalOut)
#pragma config(Sensor, in9,    UPPER_ARM_FORWARD, sensorDigitalOut)
#pragma config(Sensor, in10,   TURNTABLE_FORWARD, sensorDigitalOut)
#pragma config(Sensor, in12,   STATE_0,        sensorDigitalOut)
#pragma config(Sensor, in13,   STATE_1,        sensorDigitalOut)
#pragma config(Sensor, in14,   STATE_2,        sensorDigitalOut)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* DOCUMENTATION */
/* signalSend - Sends the signals to the motors on the rising edge of the signal
* axis0, axis1, axis2 - Binary signal to determine axis
* axis0 is least significant, axis2 is most significant [000 = axis0-axis1-axis2]
*
* 000 - Undefined
* 001 - Claw Motor
* 010 - Claw Tilting Motor
* 011 - Undefined
* 100 - Upper Arm Motor
* 101 - Lower Arm Motor
* 110 - Turntable Motor
* 111 - Undefined
*
* motorOutput[] -> [0] = axis0, [1] = axis1, [2] = axis2
*
* motorA, motorB, motorC, motorD - Phases of the stepper motors
*
*
*
*/

/* Program Variables */
int joystickThreshold = 30;

struct { // Determines if the motor should be running
	bool claw;
	bool clawTilting;
	bool upperArm;
	bool lowerArm;
	bool turntable;
}Motors;
Motors motors;

struct {
	bool clawForward;
	bool clawTiltingForward;
	bool upperArmForward;
	bool lowerArmForward;
	bool turntableForward;
}MotorDirections;
MotorDirections motorDirections;

struct {
	bool motorAState;
	bool motorBState;
	bool motorCState;
	bool motorDState;
}MotorState;
MotorState motorState;

void initialize() {
	motors.claw = false;
	motors.clawTilting = false;
	motors.upperArm = false;
	motors.lowerArm = false;
	motors.turntable = false;

	motorDirections.clawForward = true;
	motorDirections.clawTiltingForward = true;
	motorDirections.upperArmForward = true;
	motorDirections.lowerArmForward = true;
	motorDirections.turntableForward = true;

	motorState.motorAState = false;
	motorState.motorBState = false;
	motorState.motorCState = false;
	motorState.motorDState = false;
}

bool isJoystickActive() {
	if (abs(vexRT[Ch1]) > joystickThreshold || abs(vexRT[Ch2]) > joystickThreshold) {
			return true;
		} else if (abs(vexRT[Ch3]) > joystickThreshold || abs(vexRT[Ch4]) > joystickThreshold) {
			return true;
		} else if (abs(vexRT[Ch5]) > joystickThreshold) {
			return true;
		}
	}
	return false;
}

void sendState(int state0, int state1, int state2) {
	SensorValue[STATE_0] = state0;
	SensorValue[STATE_1] = state1;
	SensorValue[STATE_2] = state2;
}

void sendMotors() {
	if (motors.claw) {
		SensorValue[CLAW_ON] = 1;
	} else {
		SensorValue[CLAW_ON] = 0;
	}

	if (motors.clawTilting) {
		SensorValue[CLAW_TILT_ON] = 1;
	} else {
		SensorValue[CLAW_TILT_ON] = 0;
	}

	if (motors.lowerArm) {
		SensorValue[LOWER_ARM_ON] = 1;
	} else {
		SensorValue[LOWER_ARM_ON] = 0;
	}

	if (motors.upperArm) {
		SensorValue[UPPER_ARM_ON] = 1;
	} else {
		SensorValue[UPPER_ARM_ON] = 0;
	}

	if (motors.turntable) {
		SensorValue[TURNTABLE_ON] = 1;
	} else {
		SensorValue[TURNTABLE_ON] = 0;
	}
}

void sendMotorDirections() {
	if (motorDirections.clawForward) {
		SensorValue[CLAW_FORWARD] = 1;
	} else {
		SensorValue[CLAW_FORWARD] = 0;
	}

	if (motorDirections.clawTiltingForward) {
		SensorValue[CLAW_TILT_FORWARD] = 1;
	} else {
		SensorValue[CLAW_TILT_FORWARD] = 0;
	}

	if (motorDirections.lowerArmForward) {
		SensorValue[LOWER_ARM_FORWARD] = 1;
	} else {
		SensorValue[LOWER_ARM_FORWARD] = 0;
	}

	if (motorDirections.upperArmForward) {
		SensorValue[UPPER_ARM_FORWARD] = 1;
	} else {
		SensorValue[UPPER_ARM_FORWARD] = 0;
	}

	if (motorDirections.turntableForward) {
		SensorValue[TURNTABLE_FORWARD] = 1;
	} else {
		SensorValue[TURNTABLE_FORWARD] = 0;
	}
}

void manualClawTilt() {
	if (abs(vexRT[Ch1]) > joystickThreshold) {
		motors.clawTilting = true;
		if (vexRT[Ch1] > 0) { // Move the arm up
			motorDirections.clawTiltingForward = true;
			} else { // Move the arm down
			motorDirections.clawTiltingForward = false;
			}
		} else {
		motors.clawTilting = false;
	}
}

void manualUpperArm() {
	if (abs(vexRT[Ch2]) > joystickThreshold) {
		motors.upperArm = true;
		if (vexRT[Ch2] > 0) { // Move the arm up
			motorDirections.upperArmForward = true;
			} else { // Move the arm down
			motorDirections.upperArmForward = false;
			}
		} else {
		motors.upperArm = false;
	}
}

void manualLowerArm() {
	if (abs(vexRT[Ch3]) > joystickThreshold) {
		motors.lowerArm = true;
		if (vexRT[Ch3] > 0) { // Move the arm up
			motorDirections.lowerArmForward = true;
			} else { // Move the arm down
			motorDirections.lowerArmForward = false;
			}
		} else {
		motors.lowerArm = false;
	}
}

void manualTurntable() {
	if (abs(vexRT[Ch4]) > joystickThreshold) {
		motors.turntable = true;
		if (vexRT[Ch4] > 0) { // Move the arm up
			motorDirections.turntableForward = true;
			} else { // Move the arm down
			motorDirections.turntableForward = false;
			}
		} else {
		motors.turntable = false;
	}
}

void manualClaw() {
	if (abs(vexRT[Ch5]) > joystickThreshold) {
		motors.claw = true;
		if (vexRT[Ch5] > 0) { // Move the arm up
			motorDirections.clawForward = true;
			} else { // Move the arm down
			motorDirections.clawForward = false;
			}
		} else {
		motors.claw = false;
	}
}

/* Need to implement on Arduino
void setMotorState(int state) {
SensorValue[signalSend] = 0;
switch(state) {
case 0:
SensorValue[motorA] = true;
SensorValue[motorB] = false;
SensorValue[motorC] = false;
SensorValue[motorD] = false;
break;
case 1:
SensorValue[motorA] = true;
SensorValue[motorB] = true;
SensorValue[motorC] = false;
SensorValue[motorD] = false;
break;
case 2:
SensorValue[motorA] = false;
SensorValue[motorB] = true;
SensorValue[motorC] = false;
SensorValue[motorD] = false;
break;
case 3:
SensorValue[motorA] = false;
SensorValue[motorB] = true;
SensorValue[motorC] = true;
SensorValue[motorD] = false;
break;
case 4:
SensorValue[motorA] = false;
SensorValue[motorB] = false;
SensorValue[motorC] = true;
SensorValue[motorD] = false;
break;
case 5:
SensorValue[motorA] = false;
SensorValue[motorB] = false;
SensorValue[motorC] = true;
SensorValue[motorD] = true;
break;
case 6:
SensorValue[motorA] = false;
SensorValue[motorB] = false;
SensorValue[motorC] = false;
SensorValue[motorD] = true;
break;
case 7:
SensorValue[motorA] = true;
SensorValue[motorB] = false;
SensorValue[motorC] = false;
SensorValue[motorD] = true;
break;
}
SensorValue[signalSend] = 1;
wait1Msec(delay);
}

void stepForward() {
for (int i = 0; i <= 7; i += 2) {
setMotorState(i);
}
}

void stepReverse() {
for (int i = 7; i >= 0; i -= 2) {
setMotorState(i);
}
}

bool isMotorEnabled() {
if (motors.claw) {
return true;
} else if (motors.clawTilting) {
return true;
} else if (motors.lowerArm) {
return true;
} else if (motors.upperArm) {
return true;
} else if (motors.turntable) {
return true;
}
return false;
}

void sendClaw() {
SensorValue[axis0] = false;
SensorValue[axis1] = false;
SensorValue[axis2] = true;
}

void sendClawTilting() {
SensorValue[axis0] = false;
SensorValue[axis1] = true;
SensorValue[axis2] = false;
}

void sendLowerArm() {
SensorValue[axis0] = true;
SensorValue[axis1] = false;
SensorValue[axis2] = true;
}

void sendUpperArm() {
SensorValue[axis0] = true;
SensorValue[axis1] = false;
SensorValue[axis2] = false;
}

void sendTurntable() {
SensorValue[axis0] = true;
SensorValue[axis1] = true;
SensorValue[axis2] = false;
}

task sendMotorSignals() {
while(true) {
if (isMotorEnabled()) {
// Send axis/motor to move
// Send sequence to step the motor
if (isMotorEnabled()) {
if (motors.claw) { // Spin forward
sendClaw();
if (motorDirections.clawForward) {
stepForward();
} else {
stepReverse();
}
}

if (motors.lowerArm) {
sendLowerArm();
if (motorDirections.lowerArmForward) {
stepForward();
} else {
stepReverse();
}
}

if (motors.upperArm) {
sendUpperArm();
if (motorDirections.upperArmForward) {
stepForward();
} else {
stepReverse();
}
}
}
} else {

}
}
}
*/

task armStateMachine() {
	int controllerState = 0;
	while(true) {
		if (isJoystickActive()) {
			controllerState = 0;
			} else if (vexRT[Ch6] > 0) {
			controllerState = 1;
			} else if (vexRT[Ch6] < 0) {
			controllerState = 2;
		}

		switch(controllerState) {
		case 0:
			sendState(0, 0, 0);
			break;
		case 1:
			sendState(0, 0, 1);
			break;
		case 2:
			sendState(0, 1, 0);
			break;
		}
	}
}

/*
* Need to send:
* Digital Out for each motor, if the motor is enabled
* Digital Out for each motor direction
*
*/
task main() {
	initialize();
	bVexAutonomousMode = false;
	StartTask(armStateMachine);
	while(true) {
		// Watch for controller inputs
		manualClawTilt();
		manualUpperArm();
		manualLowerArm();
		manualTurntable();
		manualClaw();

		// Send motor states out
		sendMotors();
		sendMotorDirections();
	}
}
